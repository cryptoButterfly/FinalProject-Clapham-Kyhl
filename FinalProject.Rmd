---
title: "Corona Virus: *Impact and Response*"
runtime: shiny
output: 
  html_document:
    fig_height: 3
    fig_width: 6
    toc: true
    toc_float: true
---

<style type="text/css">

h1.title {
  font-size: 38px;
  font-family: "Times New Roman", Times, serif;
  color: DarkRed;
  text-align: center;
}
</style>

<style>

body {
font-family: "Times New Roman"; 
}
</style>
```{r setup,message=FALSE,echo=FALSE}
library(readr)
library(tidyverse)
library(dplyr)
library(stringr)
library(lubridate)
library(shiny)
library(twitteR)
library(tidytext)
library(textdata)
library(gplots)
```
<br><br><br><br>

###Background statistics on spread of Corona Virus (COVID-19)
```{r,echo=FALSE}
#initial corona cases data cleanup and manipulation

#import Deaths cases data, convert to long, create Date object and unique ID for place and time
Deaths <- read.csv("time_series_19-covid-Deaths.csv")
DeathsLong <- Deaths %>%
  gather(key= "Date", value = "Deaths", 5:50) %>%
  separate(col=Date,into=c("X","date"),sep=1) %>%
  mutate(Date = mdy(date),uniqueID= paste0(Country.Region,Province.State,Date)) %>%
  select(Province.State, Country.Region, Lat, Long, Date, Deaths,uniqueID)

#import Confirmed cases data, convert to long, create Date object and unique ID for place and time
Confirmed <- read.csv("time_series_19-covid-Confirmed.csv")
ConfirmedLong <- Confirmed %>%
  gather(key= "Date", value = "Confirmed", 5:50)%>%
  separate(col=Date,into=c("X","date"),sep=1) %>%
  mutate(Date = mdy(date),uniqueID= paste0(Country.Region,Province.State,Date)) %>%
  select(Province.State, Country.Region, Lat, Long, Date, Confirmed,uniqueID)

#import Recovered cases data, convert to long, create Date object and unique ID for place and time
Recovered <- read.csv("time_series_19-covid-Recovered.csv")
RecoveredLong <- Recovered %>%
  gather(key= "Date", value = "Recovered", 5:50)%>%
  separate(col=Date,into=c("X","date"),sep=1) %>%
  mutate(Date = mdy(date),uniqueID= paste0(Country.Region,Province.State,Date)) %>%
  select(Province.State, Country.Region, Lat, Long, Date, Recovered,uniqueID)

#joining data by unique ID
DeathsConf <- left_join(DeathsLong,ConfirmedLong,by="uniqueID")
allThree <- left_join(DeathsConf,RecoveredLong,by="uniqueID")
coronaStatus <- allThree %>%
  select("Country" = Country.Region.x, "Province/State" = Province.State.x, "Latitude" = Lat.x, "Longitude" = Long.x,"Date" = Date.x,Deaths, Confirmed, Recovered) %>%
  mutate(countryNameString = as.character(Country))

#make country name a string object
coronaCountries <- coronaStatus%>%
  group_by(Country) %>%
  summarize(DeathsMean=mean(Deaths)) %>%
  mutate(countryNameString = as.character(Country))
```



```{r,echo=FALSE}
#SHINY plot giving confirmed, recovered, deaths cases based on country and a user-input y scale

#formatting
fluidPage(
  fluidRow( 
    column(width = 4,   
        wellPanel(
#allow user to chose case type, country, and y axis scale         
inputPanel(
  selectInput("x_Case", label = "Select Case Type:", 
             choices = c("Confirmed",
                         "Deaths",
                         "Recovered"),
             selected = "Confirmed"),
  selectInput("x_Country",label="Select Country:",
              choices= c("All",unlist(coronaCountries$countryNameString)),
              selected = "All"),
  radioButtons("x_Scale", label="Scale By:", 
               choices = c("World Count Confirmed","Country Count Confirmed", "No Fixed Scale"),
               selected="World Count Confirmed")
            )
          )
        ),
    column(width = 8, 
             plotOutput("statsPlot")
      )
    )
  )

#create plot
output$statsPlot <- renderPlot({ #total on a day
  #if user selects specific country, make new data set and generate plot
  if(input$x_Country != "All"){
      NEWDATA <- coronaStatus%>%
        filter(countryNameString==input$x_Country)%>%
        group_by(Date) %>%
        summarize(Deaths = sum(Deaths),Confirmed = sum(Confirmed),Recovered=sum(Recovered))
    Title2 <- paste("Number of",input$x_Case,"up to Date","in",input$x_Country)
    Graph <- ggplot(NEWDATA, aes_string(x="Date",y=input$x_Case)) +
           geom_col(fill="darkred") + 
           ggtitle(Title2)
    #scale of plot depends on the user input
    if(input$x_Scale == "World Count Confirmed"){
              newGraph <- Graph + scale_y_continuous(limits=c(0,100000))
            }
    if(input$x_Scale == "Country Count Confirmed"){
              maxCount <- (max(NEWDATA$Confirmed) + 5)
              newGraph <- Graph + scale_y_continuous(limits = c(0,maxCount))
            }
    if(input$x_Scale == "No Fixed Scale"){
              newGraph <- Graph
            }
  }
  #generates plot for all countries
  else{
    Title2 <- paste("Number of",input$x_Case,"up to Date","in World")
    Graph <- ggplot(coronaStatus, aes_string(y = input$x_Case, x="Date")) +
    geom_col(fill="darkred") +
    ggtitle(Title2) 
    #scale of plot depends on user input   
    if(input$x_Scale != "No Fixed Scale"){
          newGraph <- Graph + scale_y_continuous(limits=c(0,100000))
        }
    else{
         newGraph <- Graph
        }
  }
  newGraph + 
    theme(plot.title = element_text(hjust = 0.5)) 
})
```


```{r,echo=FALSE}
#make a world plot showing location, magnitude, spread of confirmed cases

#make a data set to control the min and max of the plot legend
coronaLegend <- coronaStatus %>%
  filter(Confirmed != 0)

fluidPage(
  fluidRow( 
    column(width = 4,   
        wellPanel(
#allow user to select date
inputPanel(
sliderInput("Day","Select Day", min = min(coronaStatus$Date),max = max(coronaStatus$Date),value = min(coronaStatus$Date), step = 1,ticks=TRUE)
            #, animate=animationOptions(interval = 300, loop = TRUE))
          )
        )
      ),
   column(width = 8, height=5,
             plotOutput("worldPlot")
    )
  )
)

output$worldPlot <- renderPlot({
  print("RenderPlot")
  glimpse(coronaStatus)
  #create data set filtering data for day selected
  thisDay <- coronaStatus%>%
    mutate(stringDay = as.character(Date)) %>%
    filter(stringDay==as.character(input$Day)) %>%
    filter(Confirmed != 0)
  #render plot
  ggplot(thisDay, aes(x=Longitude, y=Latitude)) +
    borders("world",ylim = c(-55, 95),xlim=c(-180,180)) +
    geom_point(aes(size = Confirmed),color="red") +
    scale_size(limits=c(min(coronaLegend$Confirmed),max(coronaStatus$Confirmed))) +
    coord_quickmap()  +
    xlab(label=NULL) + 
    ylab(label=NULL) +
    ggtitle("Confirmed Cases Worldwide") + 
    theme(plot.title = element_text(hjust = 0.5)) 
})
```

## Public Response: an Analysis of Corona Virus Tweets over a Day

```{r, echo = FALSE, message = FALSE, include=FALSE}
#don't have time component ready, so bring in other elements?

# in write up, mention how we only chose english tweets
tweets <- read_csv("ncov.csv")
tweets%>%
  filter(lang=="en") %>%
  select(text,favorite_count,is_retweet,retweet_count,stripped_text,created_at)

tweets$stripped_text <- str_to_lower(tweets$stripped_text)
tweetText <- tweets$stripped_text

tweetTextList <- c((str_split(tweetText,"\\.|\\'|\\ |\\!|\\,|\\#|\\@|\\(|\\)|\\?|\\:"))) #came from dictionary homework, period, or, etc. to separate words

tweetTextList2 <- unlist(tweetTextList)
wordsDF <- as.data.frame(tweetTextList2, stringsAsFactors=FALSE)



names(wordsDF) <- "word"
wordsDF <- wordsDF %>%
  group_by(word) %>%
  summarize(count = n()) %>%
  ungroup() 

  
  
```




```{r, echo =FALSE}


#grabbing the words associated with each sentiment from the nrc sentiments package
nrc_joy <- get_sentiments("nrc") %>% 
  filter(sentiment == "joy")

nrc_negative <- get_sentiments("nrc") %>% 
  filter(sentiment == "negative")

nrc_anger <- get_sentiments("nrc") %>% 
  filter(sentiment == "anger")

nrc_positive <- get_sentiments("nrc") %>% 
  filter(sentiment == "positive")

nrc_anticipation <- get_sentiments("nrc") %>% 
  filter(sentiment == "anticipation")

nrc_disgust <- get_sentiments("nrc") %>% 
  filter(sentiment == "disgust")

nrc_fear <- get_sentiments("nrc") %>% 
  filter(sentiment == "fear")

nrc_sadness <- get_sentiments("nrc") %>% 
  filter(sentiment == "sadness")

nrc_surprise <- get_sentiments("nrc") %>% 
  filter(sentiment == "surprise")

nrc_trust <- get_sentiments("nrc") %>% 
  filter(sentiment == "trust")

#matching them to the words from the tweets data frame
```

```{r,echo=FALSE}
#bringing the top 5 words from each sentiment that matched to the words collected from the twitter data
nrc_sentiments <- get_sentiments("nrc")

#this code figures out what are the most common coded words for the nrc sentiment data set
WordsMatch <- left_join(wordsDF, nrc_sentiments, by = "word") %>%
  drop_na(sentiment)

#this grabs the top 10 most used words for each sentiment
joyWordsMatch <- WordsMatch %>%
  filter(sentiment == "joy") %>%
  arrange(desc(count)) %>%
  slice(1:10)

negativeWordsMatch <- WordsMatch %>%
  filter(sentiment == "negative") %>%
  arrange(desc(count)) %>%
  slice(1:10)

angerWordsMatch <- WordsMatch %>%
    filter(sentiment == "anger") %>%
  arrange(desc(count)) %>%
  slice(1:10)

positiveWordsMatch <- WordsMatch %>%
  filter(sentiment == "positive") %>%
  arrange(desc(count)) %>%
  slice(1:10)

anticipationWordsMatch <- WordsMatch %>%
   filter(sentiment == "anticipation") %>%
  arrange(desc(count)) %>%
  slice(1:10)

disgustWordsMatch <- WordsMatch %>%
  filter(sentiment == "disgust") %>%
  arrange(desc(count)) %>%
  slice(1:10)

fearWordsMatch <- WordsMatch %>%
  filter(sentiment == "fear") %>%
  arrange(desc(count)) %>%
  slice(1:10)

sadnessWordsMatch <- WordsMatch %>%
  filter(sentiment == "sadness") %>%
  arrange(desc(count)) %>%
  slice(1:10)

surpriseWordsMatch <- WordsMatch %>%
  filter(sentiment == "surprise") %>%
  arrange(desc(count)) %>%
  slice(1:10)

trustWordsMatch <- WordsMatch %>%
  filter(sentiment == "trust") %>%
  arrange(desc(count)) %>%
  slice(1:10)

```

```{r,echo=FALSE}
#here is the shiny part, produces a bar graph where the user can choose which sentiment's top 10 words are

inputPanel(
  selectInput("x_sent", label = "Select Sentiment:", 
             choices = c("joy", "negative", "anger", "positive", "anticipation", "disgust", "fear", "sadness", "surprise", "trust"),
             selected = "fear")
)
 
renderPlot ({
  if(input$x_sent == "joy")
  {
    sentPlot <- ggplot(joyWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Joy") +
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  
  if(input$x_sent == "negative")
  {
    sentPlot <- ggplot(negativeWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words with Negative Connotation") +
      geom_col() + theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  if(input$x_sent == "anger")
  {
    sentPlot <- ggplot(angerWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Anger") + 
      geom_col() + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  

  if(input$x_sent == "positive")
  {
    sentPlot <- ggplot(positiveWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words with Positive Connotation") + 
      geom_col() + 
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  if(input$x_sent == "anticipation")
  {
    sentPlot <- ggplot(anticipationWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Anticipation") +
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
 
  
  if(input$x_sent == "disgust")
  {
    sentPlot <- ggplot(disgustWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Disgust") +
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+ 
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }

  
  if(input$x_sent == "fear")
  {
    sentPlot <- ggplot(fearWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Fear") +
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  if(input$x_sent == "sadness")
  {
    sentPlot <- ggplot(sadnessWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Sadness") +
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  if(input$x_sent == "surprise")
  {
    sentPlot <- ggplot(surpriseWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Surprise") +
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+ 
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  
  if(input$x_sent == "trust")
  {
    sentPlot <- ggplot(trustWordsMatch, aes(x=reorder(word,-count), y = count, fill= word)) +
      labs(title = "Words Associated with Trust") + 
      geom_col() +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  sentPlot
})
```


```{r, echo=FALSE}

#this gives the top 10 most popular sentiment
mostPopSent <- WordsMatch %>% 
  group_by(sentiment) %>%
  summarize(number = sum(count))

#this reorders in decreasing prevalency
mostPopSent$sentiment <- factor(mostPopSent$sentiment, levels = c("negative", "positive", "fear", "trust", "anticipation", "anger", "sadness", "disgust", "joy", "surprise"))



#this is the shiny part to give the user the choice to view the top 10 most popular sentiments in bar graph or pie chart format

inputPanel(
  radioButtons("x_totG", label="Select graph type: ", 
               choices = c("Pie Chart","Bar Chart"),
               selected="Bar Chart")
            )


renderPlot({
 if(input$x_totG == "Bar Chart")
  {
    totPlot <- ggplot(mostPopSent, aes(x=reorder(sentiment,-number), y = number, fill = sentiment)) +
      geom_col() +
      labs(title = "Most Common Sentiments on the Twittersphere") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(legend.position = "none")+
      labs(x=NULL, y="Count") +
      theme(plot.title = element_text(hjust = 0.5)) 
  }
  
  
#need to adjust legend to be in ascending order  
  
  if(input$x_totG == "Pie Chart")
  {
    totPlot <- ggplot(mostPopSent, aes(x="", y = number, fill = sentiment)) +
      geom_bar(stat="identity", width=1, color = "white")+
      coord_polar("y", start =0) +
      labs(title = "Most Common Sentiments on the Twittersphere",fill="Sentiments (Listed in Decreasing Prevalency)") +
      theme(axis.text.x = element_text(angle = 45, hjust = 1))+
      theme(plot.title = element_text(hjust = 0.5)) 
  }
totPlot
})
  
```








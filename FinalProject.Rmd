---
title: "final proj"
runtime: shiny
output: 
  html_document:
    fig_height: 3
    fig_width: 6
---
```{r,message=FALSE,echo=FALSE}
##NOTE THAT DATA IS CUMULATIVE 
#ask katie about graph scales 
#fluid Row
library(readr)
library(tidyverse)
library(dplyr)
library(stringr)
library(lubridate)
library(shiny)
```
#STATS ON CONFIRMED/DEATHS/RECOVERY
```{r,echo=FALSE}
Deaths <- read.csv("time_series_19-covid-Deaths.csv")
DeathsLong <- Deaths %>%
  gather(key= "Date", value = "Deaths", 5:50) %>%
  separate(col=Date,into=c("X","date"),sep=1) %>%
  mutate(Date = mdy(date),uniqueID= paste0(Country.Region,Province.State,Date)) %>%
  select(Province.State, Country.Region, Lat, Long, Date, Deaths,uniqueID)
Confirmed <- read.csv("time_series_19-covid-Confirmed.csv")
ConfirmedLong <- Confirmed %>%
  gather(key= "Date", value = "Confirmed", 5:50)%>%
  separate(col=Date,into=c("X","date"),sep=1) %>%
  mutate(Date = mdy(date),uniqueID= paste0(Country.Region,Province.State,Date)) %>%
  select(Province.State, Country.Region, Lat, Long, Date, Confirmed,uniqueID)
Recovered <- read.csv("time_series_19-covid-Recovered.csv")
RecoveredLong <- Recovered %>%
  gather(key= "Date", value = "Recovered", 5:50)%>%
  separate(col=Date,into=c("X","date"),sep=1) %>%
  mutate(Date = mdy(date),uniqueID= paste0(Country.Region,Province.State,Date)) %>%
  select(Province.State, Country.Region, Lat, Long, Date, Recovered,uniqueID)
DeathsConf <- left_join(DeathsLong,ConfirmedLong,by="uniqueID")
allThree <- left_join(DeathsConf,RecoveredLong,by="uniqueID")
coronaStatus <- allThree %>%
  select("Country" = Country.Region.x, "Province/State" = Province.State.x, "Latitude" = Lat.x, "Longitude" = Long.x,"Date" = Date.x,Deaths, Confirmed, Recovered) %>%
  mutate(countryNameString = as.character(Country))

coronaCountries <- coronaStatus%>%
  group_by(Country) %>%
  summarize(DeathsMean=mean(Deaths)) %>%
  mutate(countryNameString = as.character(Country))

##SHINY for different case types
```

```{r,eval=FALSE,echo=FALSE}
## fix confirmed cases
## add scale for aLL cases
inputPanel(
  selectInput("x_1", label = "Select Case Type:", 
             choices = c("Confirmed",
                         "Deaths",
                         "Recovered"),
             selected = "Confirmed"),
  selectInput("x_country",label="Select Country:",
              choices= c("All",unlist(coronaCountries$countryNameString)),
              selected = "All"),
  radioButtons("x_scale", label="Scale By:", 
               choices = c("World Count Confirmed","Country Count Confirmed", "No Fixed Scale"),
               selected="World Count Confirmed")
  )

  renderPlot({ #total on a day
  if (input$x_1 == "Confirmed") { 
    if (as.character(input$x_country) != "All"){
            thisCountryData <- coronaStatus %>% 
            filter(countryNameString==as.character(input$x_country)) %>%
            drop_na(Confirmed) %>%
            group_by(Date) %>%
            summarize(Conf = sum(Confirmed))
            
            glimpse(thisCountryData)
            print(length(thisCountryData$Conf))
            print(length(thisCountryData$Date))
            
            graph <- ggplot() +
            geom_col(thisCountryData,mapping=aes(y = Conf, x=Date)) +
            ggtitle("Confirmed Cases up to Date") +
            ylab("Confirmed Cases") 
            
            if(input$x_scale == "World Count Confirmed"){
              newGraph <- graph + scale_y_continuous(limits=c(0,100000))
            }
            if(input$x_scale == "Country Count Confirmed"){
              maxCount <- (max(thisCountryData$Confirmed) + 5)
              newGraph <- graph + scale_y_continuous(limits = c(0,maxCount))
            }
            if(input$x_scale == "No Fixed Scale"){
              newGraph <- graph
            }
        }
    else{
        graph <- ggplot(coronaStatus, aes_string(y = input$x_1, x="Date")) +
        geom_col() +
        ggtitle("Confirmed Cases up to Date") +
        ylab("Confirmed Cases") 
        if(input$x_scale != "No Fixed Scale"){
          newGraph <- graph + scale_y_continuous(limits=c(0,100000))
        }
        else{
          newGraph <- graph
        }
    }
  }
  if (input$x_1 == "Deaths") { 
    if (as.character(input$x_country) != "All"){
            thisCountryData <- coronaStatus %>% 
            filter(countryNameString==as.character(input$x_country)) %>%
            group_by(Date) %>%
            summarize(Deaths = sum(Deaths))
            
            graph <- ggplot(thisCountryData, aes_string(y = input$x_1, x="Date")) +
            geom_col() +
            ggtitle("Fatal Cases up to Date") +
            ylab("Fatal Cases") 
            
            if(input$x_scale == "World Count Confirmed"){
              newGraph <- graph + scale_y_continuous(limits=c(0,100000))
            }
            if(input$x_scale == "Country Count Confirmed"){
              maxCount <- (max(thisCountryData$Confirmed) + 5)
              newGraph <- graph + scale_y_continuous(limits = c(0,maxCount))
            }
            if(input$x_scale == "No Fixed Scale"){
              newGraph <- graph
            }
        }
    else{
        graph <- ggplot(coronaStatus, aes_string(y = input$x_1, x="Date")) +
        geom_col() +
        ggtitle("Fatal Cases up to Date") +
        ylab("Fatal Cases") 
        if(input$x_scale != "No Fixed Scale"){
          newGraph <- graph + scale_y_continuous(limits=c(0,100000))
        }
        else{
          newGraph <- graph
        }
    }
      }
  else { 
    if (as.character(input$x_country) != "All"){
            thisCountryData <- coronaStatus %>% 
            filter(countryNameString==as.character(input$x_country)) %>%
            group_by(Date) %>%
            summarize(Recovered = sum(Recovered))
            
            graph <- ggplot(thisCountryData, aes_string(y = input$x_1, x="Date")) +
            geom_col() +
            ggtitle("Recovered Cases up to Date") +
            ylab("Recovered Cases") 
            
            if(input$x_scale == "World Count Confirmed"){
              newGraph <- graph + scale_y_continuous(limits=c(0,100000))
            }
            if(input$x_scale == "Country Count Confirmed"){
              maxCount <- (max(thisCountryData$Confirmed) + 5)
              newGraph <- graph + scale_y_continuous(limits = c(0,maxCount))
            }
            if(input$x_scale == "No Fixed Scale"){
              newGraph <- graph
            }
        }
    else{
        graph <- ggplot(coronaStatus, aes_string(y = input$x_1, x="Date")) +
        geom_col() +
        ggtitle("Recovered Cases up to Date") +
        ylab("Recovered Cases") 
        
        if(input$x_scale != "No Fixed Scale"){
          newGraph <- graph + scale_y_continuous(limits=c(0,100000))
        }
        else{
          newGraph <- graph
        }
    }
  }
    newGraph
})
  
        
  ##SHINY for map 
#fig = px.choropleth(s_lat_grp, locations="Country", locationmode='country names',
                #    color="Cases", hover_name="Country", 
                   # color_continuous_scale="Sunset", title='SARS 2003')
#fig.update(layout_coloraxis_showscale=False)
#fig.show()
        
  USC <- coronaStatus%>%
filter(countryNameString=="US")%>%          
    group_by(Date) %>%
    summarize(confirmed = sum(Confirmed))
  
    USD <- coronaStatus%>%
filter(countryNameString=="US")%>%          
    group_by(Date) %>%
    summarize(deaths = sum(Deaths))
    
    USR <- coronaStatus%>%
filter(countryNameString=="US")%>%          
    group_by(Date) %>%
    summarize(rec = sum(Recovered))
```

```{r,echo=FALSE}
fluidPage(
  fluidRow( 
    column(width = 4,   
        wellPanel(
          
inputPanel(
  selectInput("x_Case", label = "Select Case Type:", 
             choices = c("Confirmed",
                         "Deaths",
                         "Recovered"),
             selected = "Confirmed"),
  selectInput("x_Country",label="Select Country:",
              choices= c("All",unlist(coronaCountries$countryNameString)),
              selected = "All"),
  radioButtons("x_Scale", label="Scale By:", 
               choices = c("World Count Confirmed","Country Count Confirmed", "No Fixed Scale"),
               selected="World Count Confirmed")
  )
)),
    column(width = 8, 
             plotOutput("statsPlot")
      )))


output$statsPlot <- renderPlot({ #total on a day
  Title <- paste("Number of",input$x_Case,"up to Date")
  if(input$x_Country != "All"){
      NEWDATA <- coronaStatus%>%
        filter(countryNameString==input$x_Country)%>%
        group_by(Date) %>%
        summarize(Deaths = sum(Deaths),Confirmed = sum(Confirmed),Recovered=sum(Recovered))

    Graph <- ggplot(NEWDATA, aes_string(x="Date",y=input$x_Case)) +
           geom_col(fill="darkred") + 
           ggtitle(Title)
    if(input$x_Scale == "World Count Confirmed"){
              newGraph <- Graph + scale_y_continuous(limits=c(0,100000))
            }
    if(input$x_Scale == "Country Count Confirmed"){
              maxCount <- (max(NEWDATA$Confirmed) + 5)
              newGraph <- Graph + scale_y_continuous(limits = c(0,maxCount))
            }
    if(input$x_Scale == "No Fixed Scale"){
              newGraph <- Graph
            }
  }
  else{
    Graph <- ggplot(coronaStatus, aes_string(y = input$x_Case, x="Date")) +
    geom_col(fill="darkred") +
    ggtitle(Title) 
        
    if(input$x_Scale != "No Fixed Scale"){
          newGraph <- Graph + scale_y_continuous(limits=c(0,100000))
        }
    else{
         newGraph <- Graph
        }
  }
  newGraph + 
    theme(plot.title = element_text(hjust = 0.5)) 
})
```


#PUBLIC HYSTERIA 
```{r}
#don't have time component ready, so bring in other elements?

tweets <- read_csv("ncov.csv")
Engcorona <- tweets%>%
  filter(lang=="en") %>%
  select(text,favorite_count,is_retweet,retweet_count,stripped_text,created_at)
Engcorona$stripped_text <- str_to_lower(Engcorona$stripped_text)
tweetText <- Engcorona$stripped_text
tweetTextList <- c((str_split(tweetText,"\\.|\\'| |\\!|\\,|\\#|\\@|\\(|\\)|\\?|\\:")))
tweetTextList2 <- unlist(tweetTextList)
wordsDF <- as.data.frame(tweetTextList2, stringsAsFactors=FALSE)
wordsDataFrame <- wordsDF %>%
  drop_na()
names(wordsDataFrame) <- "word"
wordsDFNums <- wordsDataFrame %>%
  group_by(word) %>%
  summarize(number = n()) #%>%
  #select(word not-in c("the","to","in","of","and","is","this","a","of","for","be","on","than","that","so"))

#struck_by %in% struckKey

  
  #https://www.tidytextmining.com/sentiment.html


##GET DATA CEMENTED

#sentiment analysis
#looking for keywords associated with different emotions
#track how fear is evolving over time trends 
#text mining (trump tweet analysis)
##after parsing dates and time--tidytext

##now strip the tweets. 
#go to lowercase,

##use to make a data set that counts the most popular words??
##combine w H1N1 data?
## combine w corona spread information? 

##compare to data sets with similar outbreaks!!!

#could have two tweet databases, gather them with type being CORONA or H1N1
# add a new column specofying the illness type
# compare timestamp of conception?? 

## alter dataset to give updated cases by country every day!! 
##might have to use lag function?
```

using the twitter function???

library(twitteR)

consumer_key <- consumer_key_nt
consumer_secret <- consumer_secret_nt
access_token <- access_token_nt
access_secret <- access_secret_nt

setup_twitter_oauth(consumer_key, consumer_secret, access_token, access_secret)

my_stop_words <- stop_words %>% select(-lexicon) %>% 
  bind_rows(data.frame(word = c("https", "t.co", "rt", "amp","4yig9gzh5t","fyy2ceydhi","78","fakenews")))

tweet_words_interesting <- tweet_words %>% anti_join(my_stop_words)

tweet_words_interesting %>% group_by(word) %>% tally(sort=TRUE) %>% slice(1:25) %>% ggplot(aes(x = reorder(word, 
    n, function(n) -n), y = n)) + geom_bar(stat = "identity") + theme(axis.text.x = element_text(angle = 60, 
    hjust = 1)) + xlab("")
    
    
splitList<- c((str_split(sentences,"\\.|\\'| ")))
splitVector <- unlist(splitList)
wordsinS <- str_to_lower(splitVector)

wordDF <- as.data.frame(words, stringsAsFactors=FALSE) 
wordsinSDF <- as.data.frame(wordsinS, stringsAsFactors=FALSE) 

matches <- inner_join(wordDF,wordsinSDF,by=c("words"="wordsinS"))
Matching <- distinct(matches)

distinctWords <- distinct(wordsinSDF)

nrow(Matching)/nrow(distinctWords)
